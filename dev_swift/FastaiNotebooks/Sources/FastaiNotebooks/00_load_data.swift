/*
THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
file to edit: 00_load_data.ipynb

*/
        
import Foundation
import Path
import Just

public func shell_cmd(_ launchPath: String, _ arguments: [String]) -> String?
{
    let task = Process()
    task.executableURL = URL.init(fileURLWithPath:launchPath)
    task.arguments = arguments

    let pipe = Pipe()
    task.standardOutput = pipe
    do {try task.run()} catch {print("Unexpected error: \(error).")}

    let data = pipe.fileHandleForReading.readDataToEndOfFile()
    let output = String(data: data, encoding: String.Encoding.utf8)

    return output
}

public func download_file(_ url: String, dest: String?=nil, force: Bool=false){
    let dest_name = (dest ?? (Path.cwd/url.split(separator: "/").last!).string)
    let url_dest = URL.init(fileURLWithPath: (dest ?? (Path.cwd/url.split(separator: "/").last!).string))
    if (force || !Path(dest_name)!.exists){
        print("Downloading \(url)...")
        if let cts = Just.get(url).content{
            do    {try cts.write(to: URL.init(fileURLWithPath:dest_name))}
            catch {print("Can't write to \(url_dest).\n\(error)")}
        } else {print("Can't reach \(url)")}
    }
}

import TensorFlow

protocol ConvertableFromByte {
    init(_ d:UInt8)
}

extension Float : ConvertableFromByte{}
extension Int32 : ConvertableFromByte{}

func get_data<T:ConvertableFromByte & TensorFlowScalar>(_ fn:String, _ skip:Int) -> Tensor<T> {
    let data = try! Data.init(contentsOf: URL.init(fileURLWithPath: fn)).dropFirst(skip)
    return Tensor(data.map(T.init))
}

public struct MnistDataset{
    let base_url = "http://yann.lecun.com/exdb/mnist/"
    let trn_imgs = "train-images-idx3-ubyte"
    let trn_lbls = "train-labels-idx1-ubyte"
    let val_imgs = "t10k-images-idx3-ubyte"
    let val_lbls = "t10k-labels-idx1-ubyte" 
    
    var path = Path.cwd
    
    public init(path: Path){
        self.path = path
        if !path.exists {try! path.mkdir(.p)}
        let data_files = [path/trn_imgs, path/trn_lbls, path/val_imgs, path/val_lbls]
        for file in data_files{
            if !file.exists {
                let fname = file.basename()
                download_file("\(base_url)\(fname).gz", dest:(path/"\(fname).gz").string)
                _ = shell_cmd("/bin/gunzip", ["-fq", (path/"\(fname).gz").string])
            }
        }
    }
    
    func get_data<T:ConvertableFromByte & TensorFlowScalar>(_ fn:String, _ skip:Int) -> Tensor<T> {
        let data = try! Data.init(contentsOf: URL.init(fileURLWithPath: fn)).dropFirst(skip)
        return Tensor(data.map(T.init))
    }
    
    public var xTrain: Tensor<Float> {return get_data((path/trn_imgs).string, 16)/255.0}
    public var yTrain: Tensor<Int32> {return get_data((path/trn_lbls).string, 8)}
    public var xValid: Tensor<Float> {return get_data((path/val_imgs).string, 16)/255.0}
    public var yValid: Tensor<Int32> {return get_data((path/val_lbls).string, 8)}
}

import Dispatch
public func time(_ function: () -> ()) {
    let start = DispatchTime.now()
    function()
    let end = DispatchTime.now()
    let nanoseconds = Double(end.uptimeNanoseconds - start.uptimeNanoseconds)
    let milliseconds = nanoseconds / 1e6
    print("\(milliseconds) ms")
}

public func time(repeating: Int, _ function: () -> ()) {
    var times:[Double] = []
    for _ in 1...repeating{
        let start = DispatchTime.now()
        function()
        let end = DispatchTime.now()
        let nanoseconds = Double(end.uptimeNanoseconds - start.uptimeNanoseconds)
        let milliseconds = nanoseconds / 1e6
        times.append(milliseconds)
    }
    print("\(times.reduce(0.0, +)/Double(times.count)) ms")
}

func notebook2script(fname: String){
    let url_fname = URL.init(fileURLWithPath: fname)
    let last = fname.lastPathComponent
    let out_fname = (url_fname.deletingLastPathComponent().appendingPathComponent("FastaiNotebooks", isDirectory: true)
                     .appendingPathComponent("Sources", isDirectory: true)
                     .appendingPathComponent("FastaiNotebooks", isDirectory: true).appendingPathComponent(last)
                     .deletingPathExtension().appendingPathExtension("swift"))
    do{
        let data = try Data.init(contentsOf: url_fname)
        let json_data = try! JSONSerialization.jsonObject(with: data, options: .allowFragments) as! [String: Any]
        let cells = json_data["cells"] as! [[String:Any]]
        var module = """
/*
THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
file to edit: \(fname.lastPathComponent)

*/
        
"""
        for cell in cells{
            if let source = cell["source"] as? [String]{
                if source.isEmpty {continue}
                if source[0].range(of: #"^\s*//\s*export\s*$"#, options: .regularExpression) != nil{
                    module.append("\n" + source[1...].joined() + "\n")
                }
            }
        }
        try? module.write(to: out_fname, atomically: false, encoding: .utf8)
    } catch {print("Can't read the content of \(fname)")}
}

public func export_notebooks(_ path: Path){
    for entry in try! path.ls(){
        if entry.kind == Entry.Kind.file{
            if entry.path.basename().range(of: #"^\d*_.*ipynb$"#, options: .regularExpression) != nil { 
                print("Converting \(entry.path.basename())")
                notebook2script(fname: entry.path.basename())
            }
        }
    }
}
